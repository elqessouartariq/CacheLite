package api

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/redis/go-redis/v9"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
)

type Post struct {
	ID       int       `json:"id"`
	UserID   int       `json:"userId"`
	Title    string    `json:"title"`
	Body     string    `json:"body"`
	Comments []Comment `json:"comments"`
}

type Comment struct {
	ID     int    `json:"id"`
	PostID int    `json:"postId"`
	Name   string `json:"name"`
	Email  string `json:"email"`
	Body   string `json:"body"`
}

var postsFetched = false
var commentsFetched = false

func GetPostsWithoutCache(mongoClient *mongo.Client, w http.ResponseWriter, r *http.Request) ([]Post, error) {
	postCollection := mongoClient.Database("proxy-db").Collection("posts")
	commentCollection := mongoClient.Database("proxy-db").Collection("comments")

	var posts []Post

	if !postsFetched {
		resp, err := http.Get("https://jsonplaceholder.typicode.com/posts")
		if err != nil {
			panic(err)
		}
		defer resp.Body.Close()

		err = json.NewDecoder(resp.Body).Decode(&posts)
		if err != nil {
			panic(err)
		}

		for _, post := range posts {
			_, err := postCollection.InsertOne(context.Background(), post)
			if err != nil {
				panic(err)
			}
		}

		postsFetched = true
	} else {
		query := bson.M{}
		cursor, err := postCollection.Find(context.Background(), query)
		if err != nil {
			panic(err)
		}

		if err = cursor.All(context.Background(), &posts); err != nil {
			panic(err)
		}
	}

	for i, post := range posts {
		var comments []Comment

		if !commentsFetched {
			resp, err := http.Get(fmt.Sprintf("https://jsonplaceholder.typicode.com/posts/%d/comments", post.ID))
			if err != nil {
				panic(err)
			}
			defer resp.Body.Close()

			err = json.NewDecoder(resp.Body).Decode(&comments)
			if err != nil {
				panic(err)
			}

			for _, comment := range comments {
				_, err := commentCollection.InsertOne(context.Background(), comment)
				if err != nil {
					panic(err)
				}
			}

			commentsFetched = true
		} else {
			query := bson.M{"postId": post.ID}
			cursor, err := commentCollection.Find(context.Background(), query)
			if err != nil {
				panic(err)
			}

			if err = cursor.All(context.Background(), &comments); err != nil {
				panic(err)
			}
		}

		posts[i].Comments = comments
	}

	w.WriteHeader(http.StatusOK)
	w.Header().Add("Content-Type", "application/json")
	json.NewEncoder(w).Encode(posts)

	return posts, nil
}

func GetPostsWithCache(client *redis.Client, mongoClient *mongo.Client, w http.ResponseWriter, r *http.Request) {
	var posts []Post

	cachedPosts, err := client.Get(context.Background(), "posts").Result()
	if err == redis.Nil {
		fmt.Println("Cache miss")

		posts, err = GetPostsWithoutCache(mongoClient, w, r)
		if err != nil {
			panic(err)
		}

		for i, post := range posts {
			comments, err := GetCommentsForPost(mongoClient, post.ID)
			if err != nil {
				panic(err)
			}
			posts[i].Comments = comments
		}

		postsJson, err := json.Marshal(posts)
		if err != nil {
			panic(err)
		}

		err = client.Set(context.Background(), "posts", postsJson, 20*time.Second).Err()
		if err != nil {
			panic(err)
		}
	} else if err != nil {
		panic(err)
	} else {
		fmt.Println("Cache hit")

		err = json.Unmarshal([]byte(cachedPosts), &posts)
		if err != nil {
			panic(err)
		}
	}

	w.WriteHeader(http.StatusOK)
	w.Header().Add("Content-Type", "application/json")
	json.NewEncoder(w).Encode(posts)
}

func GetCommentsForPost(mongoClient *mongo.Client, postID int) ([]Comment, error) {
	var comments []Comment

	collection := mongoClient.Database("proxy-db").Collection("comments")

	filter := bson.M{"postid": postID}

	cur, err := collection.Find(context.Background(), filter)
	if err != nil {
		return nil, err
	}
	defer cur.Close(context.Background())

	for cur.Next(context.Background()) {
		var comment Comment
		err := cur.Decode(&comment)
		if err != nil {
			return nil, err
		}
		comments = append(comments, comment)
	}

	if err := cur.Err(); err != nil {
		return nil, err
	}

	return comments, nil
}
